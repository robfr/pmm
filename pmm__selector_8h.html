<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>pmm: /home/rhiggins/phd/pmm_github/src/pmm_selector.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">pmm
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pmm_selector.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="pmm__interval_8h_source.html">pmm_interval.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="pmm__model_8h_source.html">pmm_model.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="pmm__load_8h_source.html">pmm_load.h</a>&quot;</code><br/>
</div>
<p><a href="pmm__selector_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a88b607d0a67f7a5d0df4747c15608779"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm__selector_8h.html#a88b607d0a67f7a5d0df4747c15608779">multi_random_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:a5456b8440d0037cffd3c8928e57c4bf0"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm__selector_8h.html#a5456b8440d0037cffd3c8928e57c4bf0">naive_1d_bisect_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:aa2b222d3ac0479e4e0f657c969e01e98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm__selector_8h.html#aa2b222d3ac0479e4e0f657c969e01e98">naive_1d_bisect_insert_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b)</td></tr>
<tr class="memitem:aea58aec78b0aba344c4332266eeb3294"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm__selector_8h.html#aea58aec78b0aba344c4332266eeb3294">multi_naive_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:ab7f013d04bc554c71ea11ba1fe2ffa3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm__selector_8h.html#ab7f013d04bc554c71ea11ba1fe2ffa3e">multi_naive_insert_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b)</td></tr>
<tr class="memitem:a82f337eb3386410813f5135a60811f57"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm__selector_8h.html#a82f337eb3386410813f5135a60811f57">multi_gbbp_naive_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:adcc4067e41409ac46c806b2f2fc619d9"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm__selector_8h.html#adcc4067e41409ac46c806b2f2fc619d9">multi_gbbp_diagonal_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:a34b247ec5756844a437899a17e31d2fd"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm__selector_8h.html#a34b247ec5756844a437899a17e31d2fd">multi_gbbp_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:aeeee1b08f092e9bb40ab829caa8eb438"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pmm__selector_8h.html#aeeee1b08f092e9bb40ab829caa8eb438">multi_gbbp_insert_bench</a> (struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *h, struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b)</td></tr>
</table>
<h2>Function Documentation</h2>
<a class="anchor" id="adcc4067e41409ac46c806b2f2fc619d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* multi_gbbp_diagonal_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new point to benchmark using the Multidimensional Diagonal GBBP method. Briefly, this method first constructs, using the GBBP algorithm, on an interval from the start point of all parameter definitions to the end point of those definitions. After construction along this interval is complete, all points that were measured along it are used to project new construction intervals. From each point N construction intervals are projected parallel to each of the N parameter axes. GBBP is then applied to these new construction intervals, completing the model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine for which we will find a new benchmark point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an array describing the new benchmark point or NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="aeeee1b08f092e9bb40ab829caa8eb438"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int multi_gbbp_insert_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a benchmark into a multi-parameter model being constructed with the GBBP method.</p>
<p>The second half of the gbbp proceedure. After a benchmark has been made it must be added to the model and the state of the building proceedure must be adjusted according to the new shape of the model.</p>
<p>The rules that govern this adjustment and the specific adjustments are as follows:</p>
<p>if the model is empty, we add the benchmark to the model and set the state to be climbing.</p>
<p>if the model is climbing we test the new benchmark to see if the model is still climbing, or has levelled out, or has begun to decrease. If the model is not still climbing or levelled out, we change the state to bisection. The bisection state permits the optimal selection of new benchmarking points.</p>
<p>In this state, any new benchmark being inserted is comparted to the existing model. If the model already accurately approximates the benchmark the state is set to inflection.</p>
<p>The inflection state is a second level of bisection, in this state if a new benchmark is again accurately approximated by the existing model we deem the model to be complete in this region</p>
<p>Most of this functionality is actually implemented in a deeper function <a class="el" href="pmm__selector_8c.html#a1d320975d86d119e6b950c78d4a313d1">process_interval()</a>, <a class="el" href="pmm__selector_8c.html#a60cb009e16d60782c83ab8655545896c">process_it_gbbp_climb()</a>, <a class="el" href="pmm__selector_8c.html#a5a31bb9019f68803df994b90d957ba73">process_it_gbbp_bisect()</a>, etc.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure to process intervals, -2 on failure to insert benchmark</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>pointer to the load history </td></tr>
    <tr><td class="paramname">r</td><td>pointer to the routine to which the benchmark is added </td></tr>
    <tr><td class="paramname">b</td><td>pointer to the benchmark to be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 onsucces, -1 on failure to process intervals, -2 on complete failure to add benchmark to model </dd></dl>

</div>
</div>
<a class="anchor" id="a82f337eb3386410813f5135a60811f57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* multi_gbbp_naive_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new point to benchmark using the Multidimensional Naive GBBP method. Briefly, this method initialises construction intervals in a grid form, through all possible points as defined by the parameter definitions. Then GBBP is applied to all construction intervals to select benchmark points, until the model has been built along all lines in the grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine for which we will find a new benchmark point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an array describing the new benchmark point or NULL on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a34b247ec5756844a437899a17e31d2fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* multi_gbbp_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>multi_gbbp - builds multi-parameter piece-wise performance models using the GBBP optimisation</p>
<p>Alorithm description:</p>
<p>init</p>
<ul>
<li>push boundary_complete onto empty interval stack</li>
<li>for each parameter of the model<ul>
<li>push boundary model of that parameter onto interval stack</li>
</ul>
</li>
</ul>
<p>main</p>
<ul>
<li>read interval from top of stack</li>
<li>if interval is of of a boundary type<ul>
<li>apply GBBP to the construction of the boundary model</li>
</ul>
</li>
<li>if interval is tagged boundary_complete<ul>
<li>mesh points on each boundary model to create interior benchmark points. Push each of these points onto the interval stack with a point_inteval tag.</li>
<li>pop the top point_interval and execute a benchmark on it</li>
</ul>
</li>
<li>if interval is of the point_interval type<ul>
<li>execute a benchmark on the point and add to model</li>
</ul>
</li>
<li>if stack is empty<ul>
<li>mark model construction as complete </li>
</ul>
</li>
</ul>

</div>
</div>
<a class="anchor" id="ab7f013d04bc554c71ea11ba1fe2ffa3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int multi_naive_insert_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process the insertion of a new benchmark into a model being constructed with a naive method. </p>

</div>
</div>
<a class="anchor" id="aea58aec78b0aba344c4332266eeb3294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* multi_naive_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select a new benchmark following a naive construction method where every possible point in the model is benchmarked.</p>
<p>This action is simply taking the top interval from the construction stack and returning the parameters it describes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine who's model is under construction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to newly allocated parameter array describing next bench point or NULL on error </dd></dl>

</div>
</div>
<a class="anchor" id="a88b607d0a67f7a5d0df4747c15608779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* multi_random_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>builds a multi-parameter piece-wise performance model using a random selection of benchmark points</p>
<p>Alogirthm description:</p>
<p>if model is empty select start values for all parameters and return benchmark point else seed random generator</p>
<p>for each parameter select a random parameter size based on the paramdef limits and return</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to routine for which the model is being built</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to newly allocated array describing parameters for the benchmark </dd></dl>

</div>
</div>
<a class="anchor" id="aa2b222d3ac0479e4e0f657c969e01e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int naive_1d_bisect_insert_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a benchmark into a 1 parameter model being constructed with the naive bisection method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine forwhich the model is being constructed </td></tr>
    <tr><td class="paramname">b</td><td>benchmark to insert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure to process intervals, -2 on failure to insert benchmark </dd></dl>

</div>
</div>
<a class="anchor" id="a5456b8440d0037cffd3c8928e57c4bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* naive_1d_bisect_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new point to benchmark using the naive bisection in 1 dimension method. Briefly, this method initialises a bisection construction interval across the problem space (1-d only). Then recursively bisects this interval and benchmarks at bisection points, until it is no longer divisible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine for which we will find a new benchmark point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an array describing the new benchmark point or NULL on failure </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 5 2013 14:46:34 for pmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
