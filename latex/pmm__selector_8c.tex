\hypertarget{pmm__selector_8c}{\section{/home/rhiggins/phd/pmm\-\_\-github/src/pmm\-\_\-selector.c File Reference}
\label{pmm__selector_8c}\index{/home/rhiggins/phd/pmm\-\_\-github/src/pmm\-\_\-selector.\-c@{/home/rhiggins/phd/pmm\-\_\-github/src/pmm\-\_\-selector.\-c}}
}


Code for chosing benchmark points.  


{\ttfamily \#include $<$stdlib.\-h$>$}\\*
{\ttfamily \#include \char`\"{}pmm\-\_\-model.\-h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}pmm\-\_\-selector.\-h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}pmm\-\_\-interval.\-h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}pmm\-\_\-param.\-h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}pmm\-\_\-load.\-h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}pmm\-\_\-log.\-h\char`\"{}}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{pmm__selector_8c_a1237701870be277692964ab748b9ae7f}{check\-\_\-benchmarking\-\_\-minimums} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, double t, int n)
\item 
int \hyperlink{pmm__selector_8c_a8a969ec8f737d078f23f63752eeec87b}{rand\-\_\-between} (int min, int max)
\item 
int \hyperlink{pmm__selector_8c_ac5616694d832dbe1b3eec4b32dae83a7}{init\-\_\-naive\-\_\-1d\-\_\-intervals} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r)
\item 
int \hyperlink{pmm__selector_8c_a92b97347d3b0d3878c3d2ee9aea78c5f}{init\-\_\-gbbp\-\_\-naive\-\_\-intervals} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r)
\item 
int \hyperlink{pmm__selector_8c_a8f59ac8e50ffb375f0e961d38d32229c}{init\-\_\-gbbp\-\_\-diagonal\-\_\-interval} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r)
\item 
int \hyperlink{pmm__selector_8c_ab51341bc23606f2b7d76956a4b7d74df}{init\-\_\-gbbp\-\_\-boundary\-\_\-intervals} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r)
\item 
int \hyperlink{pmm__selector_8c_a55d8987af3a5f3ac75ad7f3af74cf7e9}{naive\-\_\-process\-\_\-interval\-\_\-list} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__benchmark}{pmm\-\_\-benchmark} $\ast$b)
\item 
int \hyperlink{pmm__selector_8c_a89d53446deeabfc1cfc6c3380d5e86c7}{process\-\_\-interval\-\_\-list} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__benchmark}{pmm\-\_\-benchmark} $\ast$b, struct \hyperlink{structpmm__loadhistory}{pmm\-\_\-loadhistory} $\ast$h)
\item 
int \hyperlink{pmm__selector_8c_a1d320975d86d119e6b950c78d4a313d1}{process\-\_\-interval} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i, struct \hyperlink{structpmm__benchmark}{pmm\-\_\-benchmark} $\ast$b, struct \hyperlink{structpmm__loadhistory}{pmm\-\_\-loadhistory} $\ast$h)
\item 
int \hyperlink{pmm__selector_8c_adf60cbb408d9407a003eec3a8032a8c7}{process\-\_\-it\-\_\-gbbp\-\_\-empty} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i)
\item 
int \hyperlink{pmm__selector_8c_a60cb009e16d60782c83ab8655545896c}{process\-\_\-it\-\_\-gbbp\-\_\-climb} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i, struct \hyperlink{structpmm__benchmark}{pmm\-\_\-benchmark} $\ast$b, struct \hyperlink{structpmm__loadhistory}{pmm\-\_\-loadhistory} $\ast$h)
\item 
int \hyperlink{pmm__selector_8c_a5a31bb9019f68803df994b90d957ba73}{process\-\_\-it\-\_\-gbbp\-\_\-bisect} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i, struct \hyperlink{structpmm__benchmark}{pmm\-\_\-benchmark} $\ast$b, struct \hyperlink{structpmm__loadhistory}{pmm\-\_\-loadhistory} $\ast$h)
\item 
int \hyperlink{pmm__selector_8c_a1f92d9d73974a4158582f512794c75bd}{process\-\_\-it\-\_\-gbbp\-\_\-inflect} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i, struct \hyperlink{structpmm__benchmark}{pmm\-\_\-benchmark} $\ast$b, struct \hyperlink{structpmm__loadhistory}{pmm\-\_\-loadhistory} $\ast$h)
\item 
int \hyperlink{pmm__selector_8c_a66edda4b90cc972c59e1218936499632}{process\-\_\-it\-\_\-point} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i)
\item 
int \hyperlink{pmm__selector_8c_ae5b5e81cfa4bacb727711dd557da5ddb}{naive\-\_\-step\-\_\-interval} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$interval)
\item 
int \hyperlink{pmm__selector_8c_a12336867ec278870f344473f1c7b05ed}{adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-max} (struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i, struct \hyperlink{structpmm__paramdef__set}{pmm\-\_\-paramdef\-\_\-set} $\ast$pd\-\_\-set)
\item 
int \hyperlink{pmm__selector_8c_a7a176a00a71af40516305b1bfe7038e6}{adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-min} (struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i, struct \hyperlink{structpmm__paramdef__set}{pmm\-\_\-paramdef\-\_\-set} $\ast$pd\-\_\-set)
\item 
int \hyperlink{pmm__selector_8c_a67bb6a5e4a0f0a60fa6f72ea571eacc6}{set\-\_\-params\-\_\-step\-\_\-along\-\_\-climb\-\_\-interval} (int $\ast$params, int step, struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i, struct \hyperlink{structpmm__paramdef__set}{pmm\-\_\-paramdef\-\_\-set} $\ast$pd\-\_\-set)
\item 
void \hyperlink{pmm__selector_8c_af0b037601262a05a6d04d07c4f4a1f58}{set\-\_\-params\-\_\-interval\-\_\-midpoint} (int $\ast$p, struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i)
\item 
int \hyperlink{pmm__selector_8c_a6ea3328595730175e11f693fd5183f16}{isnonzero\-\_\-at\-\_\-interval\-\_\-end} (struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i, struct \hyperlink{structpmm__paramdef__set}{pmm\-\_\-paramdef\-\_\-set} $\ast$pd\-\_\-set)
\item 
int \hyperlink{pmm__selector_8c_a292de261fedc1c29997a8434e402dc74}{is\-\_\-interval\-\_\-divisible} (struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$i, struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r)
\item 
int \hyperlink{pmm__selector_8c_a1982a78477698e3b99563456a3b238f0}{project\-\_\-diagonal\-\_\-intervals} (struct \hyperlink{structpmm__model}{pmm\-\_\-model} $\ast$m)
\item 
struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$ \hyperlink{pmm__selector_8c_ae48d30e57a3ac7459d8eeb43d58fb0ed}{new\-\_\-projection\-\_\-interval} (int $\ast$p, struct \hyperlink{structpmm__paramdef}{pmm\-\_\-paramdef} $\ast$pd, int d, int n)
\item 
int \hyperlink{pmm__selector_8c_ac7ca0b540b3366013d76b5697ef19f5f}{find\-\_\-interval\-\_\-matching\-\_\-bench} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__benchmark}{pmm\-\_\-benchmark} $\ast$b, struct \hyperlink{structpmm__loadhistory}{pmm\-\_\-loadhistory} $\ast$h, struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$$\ast$found\-\_\-i)
\item 
int \hyperlink{pmm__selector_8c_a096c59e8b5df302dd7eb14e0a7edbeac}{multi\-\_\-gbbp\-\_\-bench\-\_\-from\-\_\-interval} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__interval}{pmm\-\_\-interval} $\ast$interval, int $\ast$params)
\item 
void \hyperlink{pmm__selector_8c_aae08ee9abe40ae2d60d6d47086e1bf0d}{mesh\-\_\-boundary\-\_\-models} (struct \hyperlink{structpmm__model}{pmm\-\_\-model} $\ast$m)
\item 
void \hyperlink{pmm__selector_8c_a388277f535f308d443164be45ccb5cbf}{recurse\-\_\-mesh} (struct \hyperlink{structpmm__model}{pmm\-\_\-model} $\ast$m, int $\ast$p, int plane, int n\-\_\-p)
\item 
int $\ast$ \hyperlink{pmm__selector_8c_aea58aec78b0aba344c4332266eeb3294}{multi\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r)
\item 
int \hyperlink{pmm__selector_8c_ab7f013d04bc554c71ea11ba1fe2ffa3e}{multi\-\_\-naive\-\_\-insert\-\_\-bench} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__benchmark}{pmm\-\_\-benchmark} $\ast$b)
\item 
int $\ast$ \hyperlink{pmm__selector_8c_a5456b8440d0037cffd3c8928e57c4bf0}{naive\-\_\-1d\-\_\-bisect\-\_\-select\-\_\-new\-\_\-bench} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r)
\item 
int $\ast$ \hyperlink{pmm__selector_8c_a88b607d0a67f7a5d0df4747c15608779}{multi\-\_\-random\-\_\-select\-\_\-new\-\_\-bench} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r)
\item 
int $\ast$ \hyperlink{pmm__selector_8c_a82f337eb3386410813f5135a60811f57}{multi\-\_\-gbbp\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r)
\item 
int $\ast$ \hyperlink{pmm__selector_8c_adcc4067e41409ac46c806b2f2fc619d9}{multi\-\_\-gbbp\-\_\-diagonal\-\_\-select\-\_\-new\-\_\-bench} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r)
\item 
int $\ast$ \hyperlink{pmm__selector_8c_a34b247ec5756844a437899a17e31d2fd}{multi\-\_\-gbbp\-\_\-select\-\_\-new\-\_\-bench} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r)
\item 
int \hyperlink{pmm__selector_8c_aa2b222d3ac0479e4e0f657c969e01e98}{naive\-\_\-1d\-\_\-bisect\-\_\-insert\-\_\-bench} (struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__benchmark}{pmm\-\_\-benchmark} $\ast$b)
\item 
int \hyperlink{pmm__selector_8c_aeeee1b08f092e9bb40ab829caa8eb438}{multi\-\_\-gbbp\-\_\-insert\-\_\-bench} (struct \hyperlink{structpmm__loadhistory}{pmm\-\_\-loadhistory} $\ast$h, struct \hyperlink{structpmm__routine}{pmm\-\_\-routine} $\ast$r, struct \hyperlink{structpmm__benchmark}{pmm\-\_\-benchmark} $\ast$b)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Code for chosing benchmark points. This is the core of the application, implementing many methods to choose benchmarking points to minimise the construction time of a model 

\subsection{Function Documentation}
\hypertarget{pmm__selector_8c_a12336867ec278870f344473f1c7b05ed}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-max@{adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-max}}
\index{adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-max@{adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-max}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-max}]{\setlength{\rightskip}{0pt plus 5cm}int adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-max (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i, }
\item[{struct {\bf pmm\-\_\-paramdef\-\_\-set} $\ast$}]{pd\-\_\-set}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a12336867ec278870f344473f1c7b05ed}
Step along an interval until the product of the parameters at the end point of the interval matches the maximum parameter product (equal or less than if nonzero\-\_\-max is set, or equal to or 1 step great than if nonzero\-\_\-max is not set).


\begin{DoxyParams}{Parameters}
{\em i} & pointer to the interval that is to be adjusted \\
\hline
{\em pd\-\_\-set} & pointer to the parameter definition set\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success or -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a7a176a00a71af40516305b1bfe7038e6}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-min@{adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-min}}
\index{adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-min@{adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-min}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-min}]{\setlength{\rightskip}{0pt plus 5cm}int adjust\-\_\-interval\-\_\-with\-\_\-param\-\_\-constraint\-\_\-min (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i, }
\item[{struct {\bf pmm\-\_\-paramdef\-\_\-set} $\ast$}]{pd\-\_\-set}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a7a176a00a71af40516305b1bfe7038e6}
Step along an interval until the product of the parameters at the end/start point of the interval matches the minium parameter product


\begin{DoxyParams}{Parameters}
{\em i} & pointer to the interval that is to be adjusted \\
\hline
{\em pd\-\_\-set} & pointer to the parameter definition set\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success or -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a1237701870be277692964ab748b9ae7f}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!check\-\_\-benchmarking\-\_\-minimums@{check\-\_\-benchmarking\-\_\-minimums}}
\index{check\-\_\-benchmarking\-\_\-minimums@{check\-\_\-benchmarking\-\_\-minimums}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{check\-\_\-benchmarking\-\_\-minimums}]{\setlength{\rightskip}{0pt plus 5cm}int check\-\_\-benchmarking\-\_\-minimums (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{double}]{t, }
\item[{int}]{n}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a1237701870be277692964ab748b9ae7f}
check benchmark execution statistics against minimum requirements in routine configuration


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine \\
\hline
{\em t} & time spent benchmarking as a double \\
\hline
{\em n} & number of benchmarks taken\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if minimums are not satisfied, 1 if they are 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_ac7ca0b540b3366013d76b5697ef19f5f}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!find\-\_\-interval\-\_\-matching\-\_\-bench@{find\-\_\-interval\-\_\-matching\-\_\-bench}}
\index{find\-\_\-interval\-\_\-matching\-\_\-bench@{find\-\_\-interval\-\_\-matching\-\_\-bench}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{find\-\_\-interval\-\_\-matching\-\_\-bench}]{\setlength{\rightskip}{0pt plus 5cm}int find\-\_\-interval\-\_\-matching\-\_\-bench (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-benchmark} $\ast$}]{b, }
\item[{struct {\bf pmm\-\_\-loadhistory} $\ast$}]{h, }
\item[{struct {\bf pmm\-\_\-interval} $\ast$$\ast$}]{found\-\_\-i}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_ac7ca0b540b3366013d76b5697ef19f5f}
Find the interval in an interval stack that corresponds to a given benchmark.

This permits adding benchmarks to the model out of the order deemed by the construction intervals.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to routine containing model and parameter definitions \\
\hline
{\em b} & pointer to benchmark whos interval we are searching for \\
\hline
{\em h} & pointer to load history \\
\hline
{\em found\-\_\-i} & pointer to address that will hold the found interval or point to N\-U\-L\-L\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on successful search (found or not found), -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_ab51341bc23606f2b7d76956a4b7d74df}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!init\-\_\-gbbp\-\_\-boundary\-\_\-intervals@{init\-\_\-gbbp\-\_\-boundary\-\_\-intervals}}
\index{init\-\_\-gbbp\-\_\-boundary\-\_\-intervals@{init\-\_\-gbbp\-\_\-boundary\-\_\-intervals}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{init\-\_\-gbbp\-\_\-boundary\-\_\-intervals}]{\setlength{\rightskip}{0pt plus 5cm}int init\-\_\-gbbp\-\_\-boundary\-\_\-intervals (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_ab51341bc23606f2b7d76956a4b7d74df}
intialize the interval stack for an empty model that will be built using a G\-B\-B\-P algorithm


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine which is having its intervals intiialized\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
o on success, -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a8f59ac8e50ffb375f0e961d38d32229c}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!init\-\_\-gbbp\-\_\-diagonal\-\_\-interval@{init\-\_\-gbbp\-\_\-diagonal\-\_\-interval}}
\index{init\-\_\-gbbp\-\_\-diagonal\-\_\-interval@{init\-\_\-gbbp\-\_\-diagonal\-\_\-interval}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{init\-\_\-gbbp\-\_\-diagonal\-\_\-interval}]{\setlength{\rightskip}{0pt plus 5cm}int init\-\_\-gbbp\-\_\-diagonal\-\_\-interval (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a8f59ac8e50ffb375f0e961d38d32229c}
Function initialises a construction interval between two points which form a diagonal through the parameter space defined by the parameter definitions. For \$n\$ parameters with defintions of start points \$s\-\_\-i\$ and end points \$e\-\_\-i\$, the diagonal starts at\-: \begin{DoxyVerb}$(s_0, s_1, ..., s_n)$
\end{DoxyVerb}


and ends at\-: \begin{DoxyVerb}$(e_0, e_1, ..., e_n)$
\end{DoxyVerb}



\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine for which the interval will be initialised\\
\hline
\end{DoxyParams}
Other intervals are added to benchmark neccessary extremeties of the parameter space and to tag the completion of the diagonal and the whole model in general.

\begin{DoxyReturn}{Returns}
0 on success or -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a92b97347d3b0d3878c3d2ee9aea78c5f}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!init\-\_\-gbbp\-\_\-naive\-\_\-intervals@{init\-\_\-gbbp\-\_\-naive\-\_\-intervals}}
\index{init\-\_\-gbbp\-\_\-naive\-\_\-intervals@{init\-\_\-gbbp\-\_\-naive\-\_\-intervals}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{init\-\_\-gbbp\-\_\-naive\-\_\-intervals}]{\setlength{\rightskip}{0pt plus 5cm}int init\-\_\-gbbp\-\_\-naive\-\_\-intervals (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a92b97347d3b0d3878c3d2ee9aea78c5f}
Function initialises a construction intervals in a grid form across the whole parameter space. To form the grid, for each parameter, for all possible parameter values on that axis, intervals are projected parallel to all other axes.

Other intervals are added to benchmark neccessary extremeties of the parameter space and to tag the completion of the diagonal and the whole model in general.

\begin{DoxyReturn}{Returns}
0 on success or -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_ac5616694d832dbe1b3eec4b32dae83a7}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!init\-\_\-naive\-\_\-1d\-\_\-intervals@{init\-\_\-naive\-\_\-1d\-\_\-intervals}}
\index{init\-\_\-naive\-\_\-1d\-\_\-intervals@{init\-\_\-naive\-\_\-1d\-\_\-intervals}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{init\-\_\-naive\-\_\-1d\-\_\-intervals}]{\setlength{\rightskip}{0pt plus 5cm}int init\-\_\-naive\-\_\-1d\-\_\-intervals (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_ac5616694d832dbe1b3eec4b32dae83a7}
Function initialises a construction intervals for 1d naive bisection. A interval covering the problem space with bisection type is created. Two further 'point' type intervals are created at the end points of the bisection interval.

\begin{DoxyReturn}{Returns}
0 on success or -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a292de261fedc1c29997a8434e402dc74}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!is\-\_\-interval\-\_\-divisible@{is\-\_\-interval\-\_\-divisible}}
\index{is\-\_\-interval\-\_\-divisible@{is\-\_\-interval\-\_\-divisible}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{is\-\_\-interval\-\_\-divisible}]{\setlength{\rightskip}{0pt plus 5cm}int is\-\_\-interval\-\_\-divisible (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i, }
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a292de261fedc1c29997a8434e402dc74}
Tests if an interval can be processed to return a benchmark from it. I.\-e. if the 'length' of the interval is enough for a new benchmark point to be returned when G\-B\-B\-P is applied to that interval.

This is achieved by applying G\-B\-B\-P to the interval, then aligning the start and end points of the interval and comparing them to the G\-B\-B\-P point.

If the G\-B\-B\-P point is equal to either the aligned start/end points, we determine that the interval is not divisible.


\begin{DoxyParams}{Parameters}
{\em i} & pointer to the interval to test \\
\hline
{\em r} & pointer to the routine that the interval belongs to\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if interval is divisible, 0 if it is not or -\/1 on error
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
interval is of type I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-C\-L\-I\-M\-B, I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-B\-I\-S\-E\-C\-T or I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-I\-N\-F\-L\-E\-C\-T
\end{DoxyPrecond}
T\-O\-D\-O 'divisible' is the wrong adjective to describe this function \hypertarget{pmm__selector_8c_a6ea3328595730175e11f693fd5183f16}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!isnonzero\-\_\-at\-\_\-interval\-\_\-end@{isnonzero\-\_\-at\-\_\-interval\-\_\-end}}
\index{isnonzero\-\_\-at\-\_\-interval\-\_\-end@{isnonzero\-\_\-at\-\_\-interval\-\_\-end}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{isnonzero\-\_\-at\-\_\-interval\-\_\-end}]{\setlength{\rightskip}{0pt plus 5cm}int isnonzero\-\_\-at\-\_\-interval\-\_\-end (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i, }
\item[{struct {\bf pmm\-\_\-paramdef\-\_\-set} $\ast$}]{pd\-\_\-set}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a6ea3328595730175e11f693fd5183f16}
Test if the end point of an interval is nonzero or not. A nonzero end point means we will benchmark at this point rather than set its speed to be zero.

The line between start and end points may be perpendicular to some axes of the parameter space, or to none at all. Any parameter-\/axis that the interval-\/line is perpendicular to, is not considered in the determination of the end point 'fuzziness'.

The end point is declared nonzero then, if all parameters that may be considered have nonzero property set to true. Other wise, the end point is not fuzzy and should have a speed set to be zero in the model.


\begin{DoxyParams}{Parameters}
{\em i} & pointer to the interval \\
\hline
{\em pd\-\_\-set} & pointer to the parameter defintion set\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if not zero end point, 1 if nonzero end point 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_aae08ee9abe40ae2d60d6d47086e1bf0d}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!mesh\-\_\-boundary\-\_\-models@{mesh\-\_\-boundary\-\_\-models}}
\index{mesh\-\_\-boundary\-\_\-models@{mesh\-\_\-boundary\-\_\-models}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{mesh\-\_\-boundary\-\_\-models}]{\setlength{\rightskip}{0pt plus 5cm}void mesh\-\_\-boundary\-\_\-models (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-model} $\ast$}]{m}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_aae08ee9abe40ae2d60d6d47086e1bf0d}
given a set of complete models along the parameter boundaries, creat a mech of new benchmarking points for the interior of the model


\begin{DoxyParams}{Parameters}
{\em m} & pointer to the model \\
\hline
\end{DoxyParams}
\hypertarget{pmm__selector_8c_a096c59e8b5df302dd7eb14e0a7edbeac}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!multi\-\_\-gbbp\-\_\-bench\-\_\-from\-\_\-interval@{multi\-\_\-gbbp\-\_\-bench\-\_\-from\-\_\-interval}}
\index{multi\-\_\-gbbp\-\_\-bench\-\_\-from\-\_\-interval@{multi\-\_\-gbbp\-\_\-bench\-\_\-from\-\_\-interval}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{multi\-\_\-gbbp\-\_\-bench\-\_\-from\-\_\-interval}]{\setlength{\rightskip}{0pt plus 5cm}int multi\-\_\-gbbp\-\_\-bench\-\_\-from\-\_\-interval (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{interval, }
\item[{int $\ast$}]{params}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a096c59e8b5df302dd7eb14e0a7edbeac}
Finds the parameters of the next benchmarking point based on a parameter interval and the G\-B\-B\-P algorithm.

The benchmarking point is aligned to the stride/offset of parameter definitions.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the relevant routine \\
\hline
{\em interval} & pointer to the interval \\
\hline
{\em params} & pointer to an array where the next point should be stored\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 if no benchmark is associated with the interval type (i.\-e. I\-T\-\_\-\-C\-O\-M\-P\-L\-E\-T\-E) or -\/2 on an error
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
params is a pointer to allocated memory of the correct size 
\end{DoxyPrecond}
\hypertarget{pmm__selector_8c_adcc4067e41409ac46c806b2f2fc619d9}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!multi\-\_\-gbbp\-\_\-diagonal\-\_\-select\-\_\-new\-\_\-bench@{multi\-\_\-gbbp\-\_\-diagonal\-\_\-select\-\_\-new\-\_\-bench}}
\index{multi\-\_\-gbbp\-\_\-diagonal\-\_\-select\-\_\-new\-\_\-bench@{multi\-\_\-gbbp\-\_\-diagonal\-\_\-select\-\_\-new\-\_\-bench}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{multi\-\_\-gbbp\-\_\-diagonal\-\_\-select\-\_\-new\-\_\-bench}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ multi\-\_\-gbbp\-\_\-diagonal\-\_\-select\-\_\-new\-\_\-bench (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_adcc4067e41409ac46c806b2f2fc619d9}
Returns a new point to benchmark using the Multidimensional Diagonal G\-B\-B\-P method. Briefly, this method first constructs, using the G\-B\-B\-P algorithm, on an interval from the start point of all parameter definitions to the end point of those definitions. After construction along this interval is complete, all points that were measured along it are used to project new construction intervals. From each point N construction intervals are projected parallel to each of the N parameter axes. G\-B\-B\-P is then applied to these new construction intervals, completing the model.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine for which we will find a new benchmark point\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to an array describing the new benchmark point or N\-U\-L\-L on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_aeeee1b08f092e9bb40ab829caa8eb438}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!multi\-\_\-gbbp\-\_\-insert\-\_\-bench@{multi\-\_\-gbbp\-\_\-insert\-\_\-bench}}
\index{multi\-\_\-gbbp\-\_\-insert\-\_\-bench@{multi\-\_\-gbbp\-\_\-insert\-\_\-bench}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{multi\-\_\-gbbp\-\_\-insert\-\_\-bench}]{\setlength{\rightskip}{0pt plus 5cm}int multi\-\_\-gbbp\-\_\-insert\-\_\-bench (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-loadhistory} $\ast$}]{h, }
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-benchmark} $\ast$}]{b}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_aeeee1b08f092e9bb40ab829caa8eb438}
Insert a benchmark into a multi-\/parameter model being constructed with the G\-B\-B\-P method.

The second half of the gbbp proceedure. After a benchmark has been made it must be added to the model and the state of the building proceedure must be adjusted according to the new shape of the model.

The rules that govern this adjustment and the specific adjustments are as follows\-:

if the model is empty, we add the benchmark to the model and set the state to be climbing.

if the model is climbing we test the new benchmark to see if the model is still climbing, or has levelled out, or has begun to decrease. If the model is not still climbing or levelled out, we change the state to bisection. The bisection state permits the optimal selection of new benchmarking points.

In this state, any new benchmark being inserted is comparted to the existing model. If the model already accurately approximates the benchmark the state is set to inflection.

The inflection state is a second level of bisection, in this state if a new benchmark is again accurately approximated by the existing model we deem the model to be complete in this region

Most of this functionality is actually implemented in a deeper function \hyperlink{pmm__selector_8c_a1d320975d86d119e6b950c78d4a313d1}{process\-\_\-interval()}, \hyperlink{pmm__selector_8c_a60cb009e16d60782c83ab8655545896c}{process\-\_\-it\-\_\-gbbp\-\_\-climb()}, \hyperlink{pmm__selector_8c_a5a31bb9019f68803df994b90d957ba73}{process\-\_\-it\-\_\-gbbp\-\_\-bisect()}, etc.

\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure to process intervals, -\/2 on failure to insert benchmark
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em h} & pointer to the load history \\
\hline
{\em r} & pointer to the routine to which the benchmark is added \\
\hline
{\em b} & pointer to the benchmark to be added\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 onsucces, -\/1 on failure to process intervals, -\/2 on complete failure to add benchmark to model 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a82f337eb3386410813f5135a60811f57}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!multi\-\_\-gbbp\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench@{multi\-\_\-gbbp\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench}}
\index{multi\-\_\-gbbp\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench@{multi\-\_\-gbbp\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{multi\-\_\-gbbp\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ multi\-\_\-gbbp\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a82f337eb3386410813f5135a60811f57}
Returns a new point to benchmark using the Multidimensional Naive G\-B\-B\-P method. Briefly, this method initialises construction intervals in a grid form, through all possible points as defined by the parameter definitions. Then G\-B\-B\-P is applied to all construction intervals to select benchmark points, until the model has been built along all lines in the grid.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine for which we will find a new benchmark point\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to an array describing the new benchmark point or N\-U\-L\-L on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a34b247ec5756844a437899a17e31d2fd}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!multi\-\_\-gbbp\-\_\-select\-\_\-new\-\_\-bench@{multi\-\_\-gbbp\-\_\-select\-\_\-new\-\_\-bench}}
\index{multi\-\_\-gbbp\-\_\-select\-\_\-new\-\_\-bench@{multi\-\_\-gbbp\-\_\-select\-\_\-new\-\_\-bench}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{multi\-\_\-gbbp\-\_\-select\-\_\-new\-\_\-bench}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ multi\-\_\-gbbp\-\_\-select\-\_\-new\-\_\-bench (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a34b247ec5756844a437899a17e31d2fd}
multi\-\_\-gbbp -\/ builds multi-\/parameter piece-\/wise performance models using the G\-B\-B\-P optimisation

Alorithm description\-:

init
\begin{DoxyItemize}
\item push boundary\-\_\-complete onto empty interval stack
\item for each parameter of the model
\begin{DoxyItemize}
\item push boundary model of that parameter onto interval stack
\end{DoxyItemize}
\end{DoxyItemize}

main
\begin{DoxyItemize}
\item read interval from top of stack
\item if interval is of of a boundary type
\begin{DoxyItemize}
\item apply G\-B\-B\-P to the construction of the boundary model
\end{DoxyItemize}
\item if interval is tagged boundary\-\_\-complete
\begin{DoxyItemize}
\item mesh points on each boundary model to create interior benchmark points. Push each of these points onto the interval stack with a point\-\_\-inteval tag.
\item pop the top point\-\_\-interval and execute a benchmark on it
\end{DoxyItemize}
\item if interval is of the point\-\_\-interval type
\begin{DoxyItemize}
\item execute a benchmark on the point and add to model
\end{DoxyItemize}
\item if stack is empty
\begin{DoxyItemize}
\item mark model construction as complete 
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{pmm__selector_8c_ab7f013d04bc554c71ea11ba1fe2ffa3e}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!multi\-\_\-naive\-\_\-insert\-\_\-bench@{multi\-\_\-naive\-\_\-insert\-\_\-bench}}
\index{multi\-\_\-naive\-\_\-insert\-\_\-bench@{multi\-\_\-naive\-\_\-insert\-\_\-bench}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{multi\-\_\-naive\-\_\-insert\-\_\-bench}]{\setlength{\rightskip}{0pt plus 5cm}int multi\-\_\-naive\-\_\-insert\-\_\-bench (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-benchmark} $\ast$}]{b}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_ab7f013d04bc554c71ea11ba1fe2ffa3e}
Process the insertion of a new benchmark into a model being constructed with a naive method. \hypertarget{pmm__selector_8c_aea58aec78b0aba344c4332266eeb3294}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!multi\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench@{multi\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench}}
\index{multi\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench@{multi\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{multi\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ multi\-\_\-naive\-\_\-select\-\_\-new\-\_\-bench (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_aea58aec78b0aba344c4332266eeb3294}
Select a new benchmark following a naive construction method where every possible point in the model is benchmarked.

This action is simply taking the top interval from the construction stack and returning the parameters it describes.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine who's model is under construction\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to newly allocated parameter array describing next bench point or N\-U\-L\-L on error 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a88b607d0a67f7a5d0df4747c15608779}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!multi\-\_\-random\-\_\-select\-\_\-new\-\_\-bench@{multi\-\_\-random\-\_\-select\-\_\-new\-\_\-bench}}
\index{multi\-\_\-random\-\_\-select\-\_\-new\-\_\-bench@{multi\-\_\-random\-\_\-select\-\_\-new\-\_\-bench}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{multi\-\_\-random\-\_\-select\-\_\-new\-\_\-bench}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ multi\-\_\-random\-\_\-select\-\_\-new\-\_\-bench (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a88b607d0a67f7a5d0df4747c15608779}
builds a multi-\/parameter piece-\/wise performance model using a random selection of benchmark points

Alogirthm description\-:

if model is empty select start values for all parameters and return benchmark point else seed random generator

for each parameter select a random parameter size based on the paramdef limits and return


\begin{DoxyParams}{Parameters}
{\em r} & pointer to routine for which the model is being built\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to newly allocated array describing parameters for the benchmark 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_aa2b222d3ac0479e4e0f657c969e01e98}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!naive\-\_\-1d\-\_\-bisect\-\_\-insert\-\_\-bench@{naive\-\_\-1d\-\_\-bisect\-\_\-insert\-\_\-bench}}
\index{naive\-\_\-1d\-\_\-bisect\-\_\-insert\-\_\-bench@{naive\-\_\-1d\-\_\-bisect\-\_\-insert\-\_\-bench}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{naive\-\_\-1d\-\_\-bisect\-\_\-insert\-\_\-bench}]{\setlength{\rightskip}{0pt plus 5cm}int naive\-\_\-1d\-\_\-bisect\-\_\-insert\-\_\-bench (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-benchmark} $\ast$}]{b}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_aa2b222d3ac0479e4e0f657c969e01e98}
Insert a benchmark into a 1 parameter model being constructed with the naive bisection method.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine forwhich the model is being constructed \\
\hline
{\em b} & benchmark to insert\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure to process intervals, -\/2 on failure to insert benchmark 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a5456b8440d0037cffd3c8928e57c4bf0}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!naive\-\_\-1d\-\_\-bisect\-\_\-select\-\_\-new\-\_\-bench@{naive\-\_\-1d\-\_\-bisect\-\_\-select\-\_\-new\-\_\-bench}}
\index{naive\-\_\-1d\-\_\-bisect\-\_\-select\-\_\-new\-\_\-bench@{naive\-\_\-1d\-\_\-bisect\-\_\-select\-\_\-new\-\_\-bench}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{naive\-\_\-1d\-\_\-bisect\-\_\-select\-\_\-new\-\_\-bench}]{\setlength{\rightskip}{0pt plus 5cm}int$\ast$ naive\-\_\-1d\-\_\-bisect\-\_\-select\-\_\-new\-\_\-bench (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a5456b8440d0037cffd3c8928e57c4bf0}
Returns a new point to benchmark using the naive bisection in 1 dimension method. Briefly, this method initialises a bisection construction interval across the problem space (1-\/d only). Then recursively bisects this interval and benchmarks at bisection points, until it is no longer divisible.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine for which we will find a new benchmark point\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to an array describing the new benchmark point or N\-U\-L\-L on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a55d8987af3a5f3ac75ad7f3af74cf7e9}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!naive\-\_\-process\-\_\-interval\-\_\-list@{naive\-\_\-process\-\_\-interval\-\_\-list}}
\index{naive\-\_\-process\-\_\-interval\-\_\-list@{naive\-\_\-process\-\_\-interval\-\_\-list}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{naive\-\_\-process\-\_\-interval\-\_\-list}]{\setlength{\rightskip}{0pt plus 5cm}int naive\-\_\-process\-\_\-interval\-\_\-list (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-benchmark} $\ast$}]{b}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a55d8987af3a5f3ac75ad7f3af74cf7e9}
Process the interval list of the naive construction method, after a new benchmark point has been aquired.

Check that the top interval corresponds to the new benchmark and if it does, step the parameter point of the top interval along to the next target point.

In the naive construction method we benchmark every possible point in the parameter space described by the parameter definitions. In general, this set of points P is given by the n-\/ary Cartesian product of the sets of each of the n parameters, p\-\_\-0, p\-\_\-1, p\-\_\-n, where such sets are defined by our parameter definitions in terms of start values, end values, stride and offsets.

We iterate through such a set of points in lexicographical order, i.\-e. given points a and b in P, they are successive iff\-:

$(a_1, a_2, \dots, a_n) <^d (b_1,b_2, \dots, b_n) \iff (\exists\ m > 0) \ (\forall\ i < m) (a_i = b_i) \land (a_m <_m b_m) $

Given a point p, incrementing it to p' involves the following\-: Increment the first term, if this incremented value is greater than the end defined for the first term (i.\-e. it has overflowed), set the term to the start value and equal start\-\_\-1 and apply this overflow by incrementing the next term, testing that the next term has not also overflowed, and letting any overflow cascade through terms of the point. You may recognise this kind of process in the natural way one counts \-:-\/)


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine \\
\hline
{\em b} & pointer to the new benchmark\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_ae5b5e81cfa4bacb727711dd557da5ddb}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!naive\-\_\-step\-\_\-interval@{naive\-\_\-step\-\_\-interval}}
\index{naive\-\_\-step\-\_\-interval@{naive\-\_\-step\-\_\-interval}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{naive\-\_\-step\-\_\-interval}]{\setlength{\rightskip}{0pt plus 5cm}int naive\-\_\-step\-\_\-interval (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{interval}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_ae5b5e81cfa4bacb727711dd557da5ddb}
Step the start point of a naive interval to the next benchmark point.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine \\
\hline
{\em interval} & pointer to the interval\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
index of the last parameter that was incremented or N (the number of parameters) when all paramters overflowed, i.\-e. the start point could not be stepped and the last naive benchmark has been reached. 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_ae48d30e57a3ac7459d8eeb43d58fb0ed}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!new\-\_\-projection\-\_\-interval@{new\-\_\-projection\-\_\-interval}}
\index{new\-\_\-projection\-\_\-interval@{new\-\_\-projection\-\_\-interval}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{new\-\_\-projection\-\_\-interval}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf pmm\-\_\-interval} $\ast$ new\-\_\-projection\-\_\-interval (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{p, }
\item[{struct {\bf pmm\-\_\-paramdef} $\ast$}]{pd, }
\item[{int}]{d, }
\item[{int}]{n}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [read]}}}\label{pmm__selector_8c_ae48d30e57a3ac7459d8eeb43d58fb0ed}
Create a new interval that is a projection through a point p, perpendicular to the plane of the d-\/th element of the point, which is described by the parameter defintion pd


\begin{DoxyParams}{Parameters}
{\em p} & pointer to the parameter array describing the point \\
\hline
{\em pd} & pointer to the parameter definition relating to the perpendicular plane \\
\hline
{\em d} & index of the perpendicular plane \\
\hline
{\em n} & number of elements in the point\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to a new interval going from p\-\_\-0,p\-\_\-1, ... start\-\_\-d, ... p\-\_\-n to p\-\_\-0, p\-\_\-1, .... end\-\_\-d, ... p\-\_\-n 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a1d320975d86d119e6b950c78d4a313d1}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!process\-\_\-interval@{process\-\_\-interval}}
\index{process\-\_\-interval@{process\-\_\-interval}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{process\-\_\-interval}]{\setlength{\rightskip}{0pt plus 5cm}int process\-\_\-interval (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i, }
\item[{struct {\bf pmm\-\_\-benchmark} $\ast$}]{b, }
\item[{struct {\bf pmm\-\_\-loadhistory} $\ast$}]{h}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a1d320975d86d119e6b950c78d4a313d1}
Process an interval based on its type.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine who's model is being constructed \\
\hline
{\em i} & pointer to the interval to process \\
\hline
{\em b} & pointer to the benchmark that is being inserted to the model \\
\hline
{\em h} & pointer to the load history defining performance fluctuation\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if processing is successful, and no further intervals should be processed, 0 if processing is successful but further intervals should be processed, -\/1 if an error occurs. 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a89d53446deeabfc1cfc6c3380d5e86c7}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!process\-\_\-interval\-\_\-list@{process\-\_\-interval\-\_\-list}}
\index{process\-\_\-interval\-\_\-list@{process\-\_\-interval\-\_\-list}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{process\-\_\-interval\-\_\-list}]{\setlength{\rightskip}{0pt plus 5cm}int process\-\_\-interval\-\_\-list (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-benchmark} $\ast$}]{b, }
\item[{struct {\bf pmm\-\_\-loadhistory} $\ast$}]{h}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a89d53446deeabfc1cfc6c3380d5e86c7}
process the interval list, with a newly aquired benchmark


\begin{DoxyParams}{Parameters}
{\em r} & pointer to routine \\
\hline
{\em b} & pointer to benchmark \\
\hline
{\em h} & load history\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on successful processing of interval, -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a5a31bb9019f68803df994b90d957ba73}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!process\-\_\-it\-\_\-gbbp\-\_\-bisect@{process\-\_\-it\-\_\-gbbp\-\_\-bisect}}
\index{process\-\_\-it\-\_\-gbbp\-\_\-bisect@{process\-\_\-it\-\_\-gbbp\-\_\-bisect}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{process\-\_\-it\-\_\-gbbp\-\_\-bisect}]{\setlength{\rightskip}{0pt plus 5cm}int process\-\_\-it\-\_\-gbbp\-\_\-bisect (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i, }
\item[{struct {\bf pmm\-\_\-benchmark} $\ast$}]{b, }
\item[{struct {\bf pmm\-\_\-loadhistory} $\ast$}]{h}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a5a31bb9019f68803df994b90d957ba73}
process a G\-B\-B\-P\-\_\-\-B\-I\-S\-E\-C\-T interval

test if the model approximates the new benchmark and in what way,

If the benchmark at the same level as the its left and right neighbours\-: assume the model is flat in the region of the interaval and finalized this area of the model by removing it.

If the benchmark is at the same level as the left neighbour only, assume that the model is flat to the left of the new benchmark, finalize this area by remoing the interval and replacing it with a new interval representing the area to the right of the benchmark.

In the benchmark is at thte same level as the right neighbour only, preform the same action, but in the inverse, replace the interval with a new interval representing the area to the left of the benchmark

In other cases, look up the current model at the position of the new benchmark.

If the current model accurately represents the new benchmark, replace the construction interval with a new G\-B\-B\-P\-\_\-\-I\-N\-F\-L\-E\-C\-T interval covering the same area.

If the current model does not accurately represent the new benchmark, replace the interval with two new G\-G\-B\-P\-\_\-\-B\-I\-S\-E\-C\-T intervals covering the left and right areas between the new benchmark and the previous interval, allowing further refinement of the model


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine \\
\hline
{\em i} & pointer to the interval being processed \\
\hline
{\em b} & pointer to the new benchmark \\
\hline
{\em h} & pointer to the load history\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a60cb009e16d60782c83ab8655545896c}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!process\-\_\-it\-\_\-gbbp\-\_\-climb@{process\-\_\-it\-\_\-gbbp\-\_\-climb}}
\index{process\-\_\-it\-\_\-gbbp\-\_\-climb@{process\-\_\-it\-\_\-gbbp\-\_\-climb}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{process\-\_\-it\-\_\-gbbp\-\_\-climb}]{\setlength{\rightskip}{0pt plus 5cm}int process\-\_\-it\-\_\-gbbp\-\_\-climb (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i, }
\item[{struct {\bf pmm\-\_\-benchmark} $\ast$}]{b, }
\item[{struct {\bf pmm\-\_\-loadhistory} $\ast$}]{h}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a60cb009e16d60782c83ab8655545896c}
Process a I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-C\-L\-I\-M\-B interval type and associated benchmark. If the new benchmark has a higher speed than the benchmark at the start/left-\/most point of the interval, then the performance is still climbing. Replace the interval with one that ranges from the new benchmark point to the old old interval end point. The new interval will have the same G\-B\-B\-P\-\_\-\-C\-L\-I\-M\-B type. Otherwise, if the performance is no longer climbing, replace the old interval with a new interval ranging from the new benchmark point to the end of the old interval, but with a G\-B\-B\-P\-\_\-\-B\-I\-S\-E\-C\-T type.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine that cotains the model \\
\hline
{\em i} & pointer to the interval that the benchmark belongs to \\
\hline
{\em b} & pointer to the benchmark \\
\hline
{\em h} & pointer to the load history (describes performance variance)\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
interval i and benchmark b match, m is the correct model, etc.
\end{DoxyPrecond}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_adf60cbb408d9407a003eec3a8032a8c7}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!process\-\_\-it\-\_\-gbbp\-\_\-empty@{process\-\_\-it\-\_\-gbbp\-\_\-empty}}
\index{process\-\_\-it\-\_\-gbbp\-\_\-empty@{process\-\_\-it\-\_\-gbbp\-\_\-empty}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{process\-\_\-it\-\_\-gbbp\-\_\-empty}]{\setlength{\rightskip}{0pt plus 5cm}int process\-\_\-it\-\_\-gbbp\-\_\-empty (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_adf60cbb408d9407a003eec3a8032a8c7}
Process a gbbp\-\_\-empty type interval. Replace interval with an I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-C\-L\-I\-M\-B interval that starts and ends at the same points as the G\-B\-B\-P\-\_\-\-E\-M\-P\-T\-Y interval it replaces.

Note, the new interval must be inserted inplace of the old one, not at the top of the interval list. The start,start,...,start set of parameters match all I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-E\-M\-P\-T\-Y intervals for all different boundary planes. We will process all of these intervals, not just the first occurance in the interval list. However, not all of the planes are ready for construction (e.\-g. their nonzero\-\_\-end benchmark may not be executed yet). Inserting the next interval (I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-C\-L\-I\-M\-P) inplace of the I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-E\-M\-P\-T\-Y interval resolves this issue.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the parent routine \\
\hline
{\em i} & pointer to the interval we are processing\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
i as the type I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-E\-M\-P\-T\-Y
\end{DoxyPrecond}
\begin{DoxyReturn}{Returns}
0 on success 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a1f92d9d73974a4158582f512794c75bd}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!process\-\_\-it\-\_\-gbbp\-\_\-inflect@{process\-\_\-it\-\_\-gbbp\-\_\-inflect}}
\index{process\-\_\-it\-\_\-gbbp\-\_\-inflect@{process\-\_\-it\-\_\-gbbp\-\_\-inflect}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{process\-\_\-it\-\_\-gbbp\-\_\-inflect}]{\setlength{\rightskip}{0pt plus 5cm}int process\-\_\-it\-\_\-gbbp\-\_\-inflect (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i, }
\item[{struct {\bf pmm\-\_\-benchmark} $\ast$}]{b, }
\item[{struct {\bf pmm\-\_\-loadhistory} $\ast$}]{h}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a1f92d9d73974a4158582f512794c75bd}
process a G\-B\-B\-P\-\_\-\-I\-N\-F\-L\-E\-C\-T interval

test if the model approximates the new benchmark and in what way,

Look up the current model at the position of the new benchmark, if the model accurately represents the new benchmark then the model is complete in this area, remove the construction interval.

Otherwise, construction must contine in this area, but\-:

If the benchmark is at the same level as the left neighbour only, assume that the model is flat to the left of the new benchmark, finalize this area by remoing the interval and replacing it with a new B\-I\-S\-E\-C\-T interval representing the area to the right of the benchmark.

In the benchmark is at thte same level as the right neighbour only, preform the same action, but in the inverse, replace the interval with a new interval representing the area to the left of the benchmark

Otherwise replace the interval with two new G\-G\-B\-P\-\_\-\-B\-I\-S\-E\-C\-T intervals covering the left and right areas between the new benchmark and the previous interval, allowing further refinement of the model.


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine \\
\hline
{\em i} & pointer to the interval being processed \\
\hline
{\em b} & pointer to the new benchmark \\
\hline
{\em h} & pointer to the load history\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a66edda4b90cc972c59e1218936499632}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!process\-\_\-it\-\_\-point@{process\-\_\-it\-\_\-point}}
\index{process\-\_\-it\-\_\-point@{process\-\_\-it\-\_\-point}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{process\-\_\-it\-\_\-point}]{\setlength{\rightskip}{0pt plus 5cm}int process\-\_\-it\-\_\-point (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-routine} $\ast$}]{r, }
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a66edda4b90cc972c59e1218936499632}
Process a point type interval. Remove interval from the interval list and if the list is now empty, add a I\-T\-\_\-\-C\-O\-M\-P\-L\-E\-T\-E interval to the list to tag that construction has been completed, also set the complete parameter of the model to 1


\begin{DoxyParams}{Parameters}
{\em r} & pointer to the routine the benchmark belongs to \\
\hline
{\em i} & pointer to the interval\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
interval i has a type I\-T\-\_\-\-P\-O\-I\-N\-T
\end{DoxyPrecond}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a1982a78477698e3b99563456a3b238f0}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!project\-\_\-diagonal\-\_\-intervals@{project\-\_\-diagonal\-\_\-intervals}}
\index{project\-\_\-diagonal\-\_\-intervals@{project\-\_\-diagonal\-\_\-intervals}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{project\-\_\-diagonal\-\_\-intervals}]{\setlength{\rightskip}{0pt plus 5cm}int project\-\_\-diagonal\-\_\-intervals (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-model} $\ast$}]{m}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a1982a78477698e3b99563456a3b238f0}
Assuming all points in the model are along a diagonal constructed by G\-B\-B\-P from start\-\_\-0, start\-\_\-1, ..., start\-\_\-n to end\-\_\-0, end\-\_\-1, ..., end\-\_\-n, project construction intervals through each diagonal point, along mutually perpendicular lines.

Or more formally, given a set n parameter definitions, describing start and end values values\-: S\-T\-A\-R\-T = start\-\_\-0, start\-\_\-1, ..., start\-\_\-n E\-N\-D = end\-\_\-0, end\-\_\-1, ..., end\-\_\-n

For each point p along a diagonal from a point (start\-\_\-0,start\-\_\-1,...,start\-\_\-n) to (end\-\_\-0, end\-\_\-1, ..., end\-\_\-n) For each element p\-\_\-i of a point p = (p\-\_\-0, p\-\_\-1, ..., p\-\_\-n) find a point a by replacing p\-\_\-i in the point p with start\-\_\-i find a point b by replacing p\-\_\-i in the point p with end\-\_\-i create a construction interval between a and b


\begin{DoxyParams}{Parameters}
{\em m} & pointer to the model\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 on failure 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a8a969ec8f737d078f23f63752eeec87b}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!rand\-\_\-between@{rand\-\_\-between}}
\index{rand\-\_\-between@{rand\-\_\-between}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{rand\-\_\-between}]{\setlength{\rightskip}{0pt plus 5cm}int rand\-\_\-between (
\begin{DoxyParamCaption}
\item[{int}]{min, }
\item[{int}]{max}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a8a969ec8f737d078f23f63752eeec87b}
find a random integer between two values (inclusive)


\begin{DoxyParams}{Parameters}
{\em min} & first integer \\
\hline
{\em max} & second integer\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
random integer between the two values passed 
\end{DoxyReturn}
\hypertarget{pmm__selector_8c_a388277f535f308d443164be45ccb5cbf}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!recurse\-\_\-mesh@{recurse\-\_\-mesh}}
\index{recurse\-\_\-mesh@{recurse\-\_\-mesh}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{recurse\-\_\-mesh}]{\setlength{\rightskip}{0pt plus 5cm}void recurse\-\_\-mesh (
\begin{DoxyParamCaption}
\item[{struct {\bf pmm\-\_\-model} $\ast$}]{m, }
\item[{int $\ast$}]{p, }
\item[{int}]{plane, }
\item[{int}]{n\-\_\-p}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a388277f535f308d443164be45ccb5cbf}
recurse through each plane of a model creating a mesh of benchmark points using the completed parameter boundaries


\begin{DoxyParams}{Parameters}
{\em m} & pointer the model \\
\hline
{\em p} & pointer to a parameter array \\
\hline
{\em plane} & current plane \\
\hline
{\em n\-\_\-p} & number of parameters/planes \\
\hline
\end{DoxyParams}
\hypertarget{pmm__selector_8c_af0b037601262a05a6d04d07c4f4a1f58}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!set\-\_\-params\-\_\-interval\-\_\-midpoint@{set\-\_\-params\-\_\-interval\-\_\-midpoint}}
\index{set\-\_\-params\-\_\-interval\-\_\-midpoint@{set\-\_\-params\-\_\-interval\-\_\-midpoint}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{set\-\_\-params\-\_\-interval\-\_\-midpoint}]{\setlength{\rightskip}{0pt plus 5cm}void set\-\_\-params\-\_\-interval\-\_\-midpoint (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{p, }
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_af0b037601262a05a6d04d07c4f4a1f58}
Sets a param array to the midpoint between start and end points of an interval.

Precision is limited to the integer type of the point definition, round up is carried out on the division.


\begin{DoxyParams}{Parameters}
{\em p} & pointer to the parameter array \\
\hline
{\em i} & pointer to the interval\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
p is allocated and i is an interval of the correct type, with start and end points set (I\-T\-\_\-\-B\-I\-S\-E\-C\-T, I\-T\-\_\-\-I\-N\-F\-L\-E\-C\-T) 
\end{DoxyPrecond}
\hypertarget{pmm__selector_8c_a67bb6a5e4a0f0a60fa6f72ea571eacc6}{\index{pmm\-\_\-selector.\-c@{pmm\-\_\-selector.\-c}!set\-\_\-params\-\_\-step\-\_\-along\-\_\-climb\-\_\-interval@{set\-\_\-params\-\_\-step\-\_\-along\-\_\-climb\-\_\-interval}}
\index{set\-\_\-params\-\_\-step\-\_\-along\-\_\-climb\-\_\-interval@{set\-\_\-params\-\_\-step\-\_\-along\-\_\-climb\-\_\-interval}!pmm_selector.c@{pmm\-\_\-selector.\-c}}
\subsubsection[{set\-\_\-params\-\_\-step\-\_\-along\-\_\-climb\-\_\-interval}]{\setlength{\rightskip}{0pt plus 5cm}int set\-\_\-params\-\_\-step\-\_\-along\-\_\-climb\-\_\-interval (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{params, }
\item[{int}]{step, }
\item[{struct {\bf pmm\-\_\-interval} $\ast$}]{i, }
\item[{struct {\bf pmm\-\_\-paramdef\-\_\-set} $\ast$}]{pd\-\_\-set}
\end{DoxyParamCaption}
)}}\label{pmm__selector_8c_a67bb6a5e4a0f0a60fa6f72ea571eacc6}
Step along the climb interval, from the start point towards the end point, forwards or backwards, a number of times.


\begin{DoxyParams}{Parameters}
{\em params} & pointer to an array to store the parameters at the n-\/th step along the interval \\
\hline
{\em step} & number of steps to take along the interval (-\/ to step backwards, + to step forwards) \\
\hline
{\em i} & pointer to the interval to step along \\
\hline
{\em pd\-\_\-set} & pointer to the parameter definition set\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
interval should have start and end points set (i.\-e. be of the type I\-T\-\_\-\-E\-M\-T\-P\-Y, I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-C\-L\-I\-M\-B, I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-B\-I\-S\-E\-C\-T, I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-I\-N\-F\-L\-E\-C\-T) though the function is only intended to operate on I\-T\-\_\-\-G\-B\-B\-P\-\_\-\-C\-L\-I\-M\-B interval types
\end{DoxyPrecond}
\begin{DoxyReturn}{Returns}
0 on success, -\/1 if the step will exceed the end-\/point of the interval or -\/2 on error 
\end{DoxyReturn}
