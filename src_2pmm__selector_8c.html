<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>pmm: /home/rhiggins/phd/pmm_github/src/pmm_selector.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">pmm
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pmm_selector.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="src_2pmm__model_8h_source.html">pmm_model.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="src_2pmm__selector_8h_source.html">pmm_selector.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="src_2pmm__interval_8h_source.html">pmm_interval.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="src_2pmm__param_8h_source.html">pmm_param.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="src_2pmm__load_8h_source.html">pmm_load.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="src_2pmm__log_8h_source.html">pmm_log.h</a>&quot;</code><br/>
</div>
<p><a href="src_2pmm__selector_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1237701870be277692964ab748b9ae7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a1237701870be277692964ab748b9ae7f">check_benchmarking_minimums</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, double t, int n)</td></tr>
<tr class="memitem:a8a969ec8f737d078f23f63752eeec87b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a8a969ec8f737d078f23f63752eeec87b">rand_between</a> (int min, int max)</td></tr>
<tr class="memitem:ac5616694d832dbe1b3eec4b32dae83a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#ac5616694d832dbe1b3eec4b32dae83a7">init_naive_1d_intervals</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:a92b97347d3b0d3878c3d2ee9aea78c5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a92b97347d3b0d3878c3d2ee9aea78c5f">init_gbbp_naive_intervals</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:a8f59ac8e50ffb375f0e961d38d32229c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a8f59ac8e50ffb375f0e961d38d32229c">init_gbbp_diagonal_interval</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:ab51341bc23606f2b7d76956a4b7d74df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#ab51341bc23606f2b7d76956a4b7d74df">init_gbbp_boundary_intervals</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:a55d8987af3a5f3ac75ad7f3af74cf7e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a55d8987af3a5f3ac75ad7f3af74cf7e9">naive_process_interval_list</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b)</td></tr>
<tr class="memitem:a89d53446deeabfc1cfc6c3380d5e86c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a89d53446deeabfc1cfc6c3380d5e86c7">process_interval_list</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b, struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *h)</td></tr>
<tr class="memitem:a1d320975d86d119e6b950c78d4a313d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a1d320975d86d119e6b950c78d4a313d1">process_interval</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b, struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *h)</td></tr>
<tr class="memitem:adf60cbb408d9407a003eec3a8032a8c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#adf60cbb408d9407a003eec3a8032a8c7">process_it_gbbp_empty</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i)</td></tr>
<tr class="memitem:a60cb009e16d60782c83ab8655545896c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a60cb009e16d60782c83ab8655545896c">process_it_gbbp_climb</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b, struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *h)</td></tr>
<tr class="memitem:a5a31bb9019f68803df994b90d957ba73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a5a31bb9019f68803df994b90d957ba73">process_it_gbbp_bisect</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b, struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *h)</td></tr>
<tr class="memitem:a1f92d9d73974a4158582f512794c75bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a1f92d9d73974a4158582f512794c75bd">process_it_gbbp_inflect</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b, struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *h)</td></tr>
<tr class="memitem:a66edda4b90cc972c59e1218936499632"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a66edda4b90cc972c59e1218936499632">process_it_point</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i)</td></tr>
<tr class="memitem:ae5b5e81cfa4bacb727711dd557da5ddb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#ae5b5e81cfa4bacb727711dd557da5ddb">naive_step_interval</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *interval)</td></tr>
<tr class="memitem:a12336867ec278870f344473f1c7b05ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a12336867ec278870f344473f1c7b05ed">adjust_interval_with_param_constraint_max</a> (struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i, struct <a class="el" href="structpmm__paramdef__set.html">pmm_paramdef_set</a> *pd_set)</td></tr>
<tr class="memitem:a7a176a00a71af40516305b1bfe7038e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a7a176a00a71af40516305b1bfe7038e6">adjust_interval_with_param_constraint_min</a> (struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i, struct <a class="el" href="structpmm__paramdef__set.html">pmm_paramdef_set</a> *pd_set)</td></tr>
<tr class="memitem:a67bb6a5e4a0f0a60fa6f72ea571eacc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a67bb6a5e4a0f0a60fa6f72ea571eacc6">set_params_step_along_climb_interval</a> (int *params, int step, struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i, struct <a class="el" href="structpmm__paramdef__set.html">pmm_paramdef_set</a> *pd_set)</td></tr>
<tr class="memitem:af0b037601262a05a6d04d07c4f4a1f58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#af0b037601262a05a6d04d07c4f4a1f58">set_params_interval_midpoint</a> (int *p, struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i)</td></tr>
<tr class="memitem:a6ea3328595730175e11f693fd5183f16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a6ea3328595730175e11f693fd5183f16">isnonzero_at_interval_end</a> (struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i, struct <a class="el" href="structpmm__paramdef__set.html">pmm_paramdef_set</a> *pd_set)</td></tr>
<tr class="memitem:a292de261fedc1c29997a8434e402dc74"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a292de261fedc1c29997a8434e402dc74">is_interval_divisible</a> (struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *i, struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:a1982a78477698e3b99563456a3b238f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a1982a78477698e3b99563456a3b238f0">project_diagonal_intervals</a> (struct <a class="el" href="structpmm__model.html">pmm_model</a> *m)</td></tr>
<tr class="memitem:ad78e30d649acfa8e5f348b171365cbd2"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#ad78e30d649acfa8e5f348b171365cbd2">new_projection_interval</a> (int *p, struct <a class="el" href="structpmm__paramdef.html">pmm_paramdef</a> *pd, int d, int n)</td></tr>
<tr class="memitem:ac7ca0b540b3366013d76b5697ef19f5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#ac7ca0b540b3366013d76b5697ef19f5f">find_interval_matching_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b, struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *h, struct <a class="el" href="structpmm__interval.html">pmm_interval</a> **found_i)</td></tr>
<tr class="memitem:a096c59e8b5df302dd7eb14e0a7edbeac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a096c59e8b5df302dd7eb14e0a7edbeac">multi_gbbp_bench_from_interval</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *interval, int *params)</td></tr>
<tr class="memitem:aae08ee9abe40ae2d60d6d47086e1bf0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#aae08ee9abe40ae2d60d6d47086e1bf0d">mesh_boundary_models</a> (struct <a class="el" href="structpmm__model.html">pmm_model</a> *m)</td></tr>
<tr class="memitem:a388277f535f308d443164be45ccb5cbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a388277f535f308d443164be45ccb5cbf">recurse_mesh</a> (struct <a class="el" href="structpmm__model.html">pmm_model</a> *m, int *p, int plane, int n_p)</td></tr>
<tr class="memitem:aea58aec78b0aba344c4332266eeb3294"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#aea58aec78b0aba344c4332266eeb3294">multi_naive_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:ab7f013d04bc554c71ea11ba1fe2ffa3e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#ab7f013d04bc554c71ea11ba1fe2ffa3e">multi_naive_insert_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b)</td></tr>
<tr class="memitem:a5456b8440d0037cffd3c8928e57c4bf0"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a5456b8440d0037cffd3c8928e57c4bf0">naive_1d_bisect_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:a88b607d0a67f7a5d0df4747c15608779"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a88b607d0a67f7a5d0df4747c15608779">multi_random_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:a82f337eb3386410813f5135a60811f57"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a82f337eb3386410813f5135a60811f57">multi_gbbp_naive_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:adcc4067e41409ac46c806b2f2fc619d9"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#adcc4067e41409ac46c806b2f2fc619d9">multi_gbbp_diagonal_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:a34b247ec5756844a437899a17e31d2fd"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#a34b247ec5756844a437899a17e31d2fd">multi_gbbp_select_new_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r)</td></tr>
<tr class="memitem:aa2b222d3ac0479e4e0f657c969e01e98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#aa2b222d3ac0479e4e0f657c969e01e98">naive_1d_bisect_insert_bench</a> (struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b)</td></tr>
<tr class="memitem:aeeee1b08f092e9bb40ab829caa8eb438"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="src_2pmm__selector_8c.html#aeeee1b08f092e9bb40ab829caa8eb438">multi_gbbp_insert_bench</a> (struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *h, struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *r, struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *b)</td></tr>
</table>
<h2>Function Documentation</h2>
<a class="anchor" id="a12336867ec278870f344473f1c7b05ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adjust_interval_with_param_constraint_max </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__paramdef__set.html">pmm_paramdef_set</a> *&#160;</td>
          <td class="paramname"><em>pd_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Step along an interval until the product of the parameters at the end point of the interval matches the maximum parameter product (equal or less than if nonzero_max is set, or equal to or 1 step great than if nonzero_max is not set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>pointer to the interval that is to be adjusted </td></tr>
    <tr><td class="paramname">pd_set</td><td>pointer to the parameter definition set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a7a176a00a71af40516305b1bfe7038e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int adjust_interval_with_param_constraint_min </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__paramdef__set.html">pmm_paramdef_set</a> *&#160;</td>
          <td class="paramname"><em>pd_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Step along an interval until the product of the parameters at the end/start point of the interval matches the minium parameter product</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>pointer to the interval that is to be adjusted </td></tr>
    <tr><td class="paramname">pd_set</td><td>pointer to the parameter definition set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a1237701870be277692964ab748b9ae7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int check_benchmarking_minimums </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>check benchmark execution statistics against minimum requirements in routine configuration</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine </td></tr>
    <tr><td class="paramname">t</td><td>time spent benchmarking as a double </td></tr>
    <tr><td class="paramname">n</td><td>number of benchmarks taken</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if minimums are not satisfied, 1 if they are </dd></dl>

</div>
</div>
<a class="anchor" id="ac7ca0b540b3366013d76b5697ef19f5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_interval_matching_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> **&#160;</td>
          <td class="paramname"><em>found_i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the interval in an interval stack that corresponds to a given benchmark.</p>
<p>This permits adding benchmarks to the model out of the order deemed by the construction intervals.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to routine containing model and parameter definitions </td></tr>
    <tr><td class="paramname">b</td><td>pointer to benchmark whos interval we are searching for </td></tr>
    <tr><td class="paramname">h</td><td>pointer to load history </td></tr>
    <tr><td class="paramname">found_i</td><td>pointer to address that will hold the found interval or point to NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful search (found or not found), -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ab51341bc23606f2b7d76956a4b7d74df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_gbbp_boundary_intervals </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>intialize the interval stack for an empty model that will be built using a GBBP algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine which is having its intervals intiialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>o on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8f59ac8e50ffb375f0e961d38d32229c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_gbbp_diagonal_interval </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function initialises a construction interval between two points which form a diagonal through the parameter space defined by the parameter definitions. For $n$ parameters with defintions of start points $s_i$ and end points $e_i$, the diagonal starts at: </p>
<pre class="fragment">$(s_0, s_1, ..., s_n)$
</pre><p>and ends at: </p>
<pre class="fragment">$(e_0, e_1, ..., e_n)$
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine for which the interval will be initialised</td></tr>
  </table>
  </dd>
</dl>
<p>Other intervals are added to benchmark neccessary extremeties of the parameter space and to tag the completion of the diagonal and the whole model in general.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a92b97347d3b0d3878c3d2ee9aea78c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_gbbp_naive_intervals </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function initialises a construction intervals in a grid form across the whole parameter space. To form the grid, for each parameter, for all possible parameter values on that axis, intervals are projected parallel to all other axes.</p>
<p>Other intervals are added to benchmark neccessary extremeties of the parameter space and to tag the completion of the diagonal and the whole model in general.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ac5616694d832dbe1b3eec4b32dae83a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int init_naive_1d_intervals </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function initialises a construction intervals for 1d naive bisection. A interval covering the problem space with bisection type is created. Two further 'point' type intervals are created at the end points of the bisection interval.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a292de261fedc1c29997a8434e402dc74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_interval_divisible </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests if an interval can be processed to return a benchmark from it. I.e. if the 'length' of the interval is enough for a new benchmark point to be returned when GBBP is applied to that interval.</p>
<p>This is achieved by applying GBBP to the interval, then aligning the start and end points of the interval and comparing them to the GBBP point.</p>
<p>If the GBBP point is equal to either the aligned start/end points, we determine that the interval is not divisible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>pointer to the interval to test </td></tr>
    <tr><td class="paramname">r</td><td>pointer to the routine that the interval belongs to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if interval is divisible, 0 if it is not or -1 on error</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>interval is of type IT_GBBP_CLIMB, IT_GBBP_BISECT or IT_GBBP_INFLECT</dd></dl>
<p>TODO 'divisible' is the wrong adjective to describe this function </p>

</div>
</div>
<a class="anchor" id="a6ea3328595730175e11f693fd5183f16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int isnonzero_at_interval_end </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__paramdef__set.html">pmm_paramdef_set</a> *&#160;</td>
          <td class="paramname"><em>pd_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if the end point of an interval is nonzero or not. A nonzero end point means we will benchmark at this point rather than set its speed to be zero.</p>
<p>The line between start and end points may be perpendicular to some axes of the parameter space, or to none at all. Any parameter-axis that the interval-line is perpendicular to, is not considered in the determination of the end point 'fuzziness'.</p>
<p>The end point is declared nonzero then, if all parameters that may be considered have nonzero property set to true. Other wise, the end point is not fuzzy and should have a speed set to be zero in the model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>pointer to the interval </td></tr>
    <tr><td class="paramname">pd_set</td><td>pointer to the parameter defintion set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if not zero end point, 1 if nonzero end point </dd></dl>

</div>
</div>
<a class="anchor" id="aae08ee9abe40ae2d60d6d47086e1bf0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mesh_boundary_models </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__model.html">pmm_model</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>given a set of complete models along the parameter boundaries, creat a mech of new benchmarking points for the interior of the model</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>pointer to the model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a096c59e8b5df302dd7eb14e0a7edbeac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int multi_gbbp_bench_from_interval </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the parameters of the next benchmarking point based on a parameter interval and the GBBP algorithm.</p>
<p>If the interval is _EMPTY, the model is empty and the starting point of the interval is returned for benchmarking</p>
<p>If the interval is _CLIMB, the model is in the initial building phase and an increment on the starting point is returned for benchmarking</p>
<p>If the interval is either _BISECT or _INFLECT then the main phase of building is in progress and the mid point between the start and end of the interval is returned for benchmarking</p>
<p>If the interval is _POINT, then the interval describes a distingt point rather than an interval and this point is returned for benchmarking</p>
<p>The benchmarking point is aligned to the stride/offset of parameter definitions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the relevant routine </td></tr>
    <tr><td class="paramname">interval</td><td>pointer to the interval </td></tr>
    <tr><td class="paramname">params</td><td>pointer to an array where the next point should be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 if no benchmark is associated with the interval type (i.e. IT_COMPLETE) or -2 on an error</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>params is a pointer to allocated memory of the correct size </dd></dl>

</div>
</div>
<a class="anchor" id="adcc4067e41409ac46c806b2f2fc619d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* multi_gbbp_diagonal_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new point to benchmark using the Multidimensional Diagonal GBBP method. Briefly, this method first constructs, using the GBBP algorithm, on an interval from the start point of all parameter definitions to the end point of those definitions. After construction along this interval is complete, all points that were measured along it are used to project new construction intervals. From each point N construction intervals are projected parallel to each of the N parameter axes. GBBP is then applied to these new construction intervals, completing the model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine for which we will find a new benchmark point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an array describing the new benchmark point or NULL on failure </dd></dl>

<p>Definition at line <a class="el" href="src_2pmm__selector_8c_source.html#l01155">1155</a> of file <a class="el" href="src_2pmm__selector_8c_source.html">pmm_selector.c</a>.</p>

</div>
</div>
<a class="anchor" id="aeeee1b08f092e9bb40ab829caa8eb438"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int multi_gbbp_insert_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a benchmark into a multi-parameter model being constructed with the GBBP method.</p>
<p>The second half of the gbbp proceedure. After a benchmark has been made it must be added to the model and the state of the building proceedure must be adjusted according to the new shape of the model.</p>
<p>The rules that govern this adjustment and the specific adjustments are as follows:</p>
<p>if the model is empty, we add the benchmark to the model and set the state to be climbing.</p>
<p>if the model is climbing we test the new benchmark to see if the model is still climbing, or has levelled out, or has begun to decrease. If the model is not still climbing or levelled out, we change the state to bisection. The bisection state permits the optimal selection of new benchmarking points.</p>
<p>In this state, any new benchmark being inserted is comparted to the existing model. If the model already accurately approximates the benchmark the state is set to inflection.</p>
<p>The inflection state is a second level of bisection, in this state if a new benchmark is again accurately approximated by the existing model we deem the model to be complete in this region</p>
<p>Most of this functionality is actually implemented in a deeper function <a class="el" href="pmm-1_80_80_2src_2pmm__selector_8c.html#a1d320975d86d119e6b950c78d4a313d1">process_interval()</a>, <a class="el" href="pmm-1_80_80_2src_2pmm__selector_8c.html#a60cb009e16d60782c83ab8655545896c">process_it_gbbp_climb()</a>, <a class="el" href="pmm-1_80_80_2src_2pmm__selector_8c.html#a5a31bb9019f68803df994b90d957ba73">process_it_gbbp_bisect()</a>, etc.</p>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure to process intervals, -2 on failure to insert benchmark</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>pointer to the load history </td></tr>
    <tr><td class="paramname">r</td><td>pointer to the routine to which the benchmark is added </td></tr>
    <tr><td class="paramname">b</td><td>pointer to the benchmark to be added</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 onsucces, -1 on failure to process intervals, -2 on complete failure to add benchmark to model </dd></dl>

<p>Definition at line <a class="el" href="src_2pmm__selector_8c_source.html#l02555">2555</a> of file <a class="el" href="src_2pmm__selector_8c_source.html">pmm_selector.c</a>.</p>

</div>
</div>
<a class="anchor" id="a82f337eb3386410813f5135a60811f57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* multi_gbbp_naive_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new point to benchmark using the Multidimensional Naive GBBP method. Briefly, this method initialises construction intervals in a grid form, through all possible points as defined by the parameter definitions. Then GBBP is applied to all construction intervals to select benchmark points, until the model has been built along all lines in the grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine for which we will find a new benchmark point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an array describing the new benchmark point or NULL on failure </dd></dl>

<p>Definition at line <a class="el" href="src_2pmm__selector_8c_source.html#l00888">888</a> of file <a class="el" href="src_2pmm__selector_8c_source.html">pmm_selector.c</a>.</p>

</div>
</div>
<a class="anchor" id="a34b247ec5756844a437899a17e31d2fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* multi_gbbp_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>builds multi-parameter piece-wise performance models using the GBBP optimisation</p>
<p>Alorithm description:</p>
<p>init</p>
<ul>
<li>push boundary_complete onto empty interval stack</li>
<li>for each parameter of the model<ul>
<li>push boundary model of that parameter onto interval stack</li>
</ul>
</li>
</ul>
<p>main</p>
<ul>
<li>read interval from top of stack</li>
<li>if interval is of of a boundary type<ul>
<li>apply GBBP to the construction of the boundary model</li>
</ul>
</li>
<li>if interval is tagged boundary_complete<ul>
<li>mesh points on each boundary model to create interior benchmark points. Push each of these points onto the interval stack with a point_inteval tag.</li>
<li>pop the top point_interval and execute a benchmark on it</li>
</ul>
</li>
<li>if interval is of the point_interval type<ul>
<li>execute a benchmark on the point and add to model</li>
</ul>
</li>
<li>if stack is empty<ul>
<li>mark model construction as complete</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine to build for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a newly allocated array containing the parameters of the selected benchmark </dd></dl>

<p>Definition at line <a class="el" href="src_2pmm__selector_8c_source.html#l02031">2031</a> of file <a class="el" href="src_2pmm__selector_8c_source.html">pmm_selector.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab7f013d04bc554c71ea11ba1fe2ffa3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int multi_naive_insert_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process the insertion of a new benchmark into a model being constructed with a naive method. </p>

<p>Definition at line <a class="el" href="src_2pmm__selector_8c_source.html#l00329">329</a> of file <a class="el" href="src_2pmm__selector_8c_source.html">pmm_selector.c</a>.</p>

</div>
</div>
<a class="anchor" id="aea58aec78b0aba344c4332266eeb3294"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* multi_naive_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select a new benchmark following a naive construction method where every possible point in the model is benchmarked.</p>
<p>This action is simply taking the top interval from the construction stack and returning the parameters it describes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine who's model is under construction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to newly allocated parameter array describing next bench point or NULL on error </dd></dl>

<p>Definition at line <a class="el" href="src_2pmm__selector_8c_source.html#l00192">192</a> of file <a class="el" href="src_2pmm__selector_8c_source.html">pmm_selector.c</a>.</p>

</div>
</div>
<a class="anchor" id="a88b607d0a67f7a5d0df4747c15608779"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* multi_random_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>builds a multi-parameter piece-wise performance model using a random selection of benchmark points</p>
<p>Alogirthm description:</p>
<p>if model is empty select start values for all parameters and return benchmark point else seed random generator</p>
<p>for each parameter select a random parameter size based on the paramdef limits and return</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to routine for which the model is being built</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to newly allocated array describing parameters for the benchmark </dd></dl>

<p>Definition at line <a class="el" href="src_2pmm__selector_8c_source.html#l00797">797</a> of file <a class="el" href="src_2pmm__selector_8c_source.html">pmm_selector.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa2b222d3ac0479e4e0f657c969e01e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int naive_1d_bisect_insert_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a benchmark into a 1 parameter model being constructed with the naive bisection method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine forwhich the model is being constructed </td></tr>
    <tr><td class="paramname">b</td><td>benchmark to insert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure to process intervals, -2 on failure to insert benchmark </dd></dl>

<p>Definition at line <a class="el" href="src_2pmm__selector_8c_source.html#l02391">2391</a> of file <a class="el" href="src_2pmm__selector_8c_source.html">pmm_selector.c</a>.</p>

</div>
</div>
<a class="anchor" id="a5456b8440d0037cffd3c8928e57c4bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* naive_1d_bisect_select_new_bench </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new point to benchmark using the naive bisection in 1 dimension method. Briefly, this method initialises a bisection construction interval across the problem space (1-d only). Then recursively bisects this interval and benchmarks at bisection points, until it is no longer divisible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine for which we will find a new benchmark point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an array describing the new benchmark point or NULL on failure </dd></dl>

<p>Definition at line <a class="el" href="src_2pmm__selector_8c_source.html#l00609">609</a> of file <a class="el" href="src_2pmm__selector_8c_source.html">pmm_selector.c</a>.</p>

</div>
</div>
<a class="anchor" id="a55d8987af3a5f3ac75ad7f3af74cf7e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int naive_process_interval_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process the interval list of the naive construction method, after a new benchmark point has been aquired.</p>
<p>Check that the top interval corresponds to the new benchmark and if it does, step the parameter point of the top interval along to the next target point.</p>
<p>In the naive construction method we benchmark every possible point in the parameter space described by the parameter definitions. In general, this set of points P is given by the n-ary Cartesian product of the sets of each of the n parameters, p_0, p_1, p_n, where such sets are defined by our parameter definitions in terms of start values, end values, stride and offsets.</p>
<p>We iterate through such a set of points in lexicographical order, i.e. given points a and b in P, they are successive iff:</p>
<p><img class="formulaInl" alt="$(a_1, a_2, \dots, a_n) <^d (b_1,b_2, \dots, b_n) \iff (\exists\ m > 0) \ (\forall\ i < m) (a_i = b_i) \land (a_m <_m b_m) $" src="form_0.png"/></p>
<p>Given a point p, incrementing it to p' involves the following: Increment the first term, if this incremented value is greater than the end defined for the first term (i.e. it has overflowed), set the term to the start value and equal start_1 and apply this overflow by incrementing the next term, testing that the next term has not also overflowed, and letting any overflow cascade through terms of the point. You may recognise this kind of process in the natural way one counts :-)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine </td></tr>
    <tr><td class="paramname">b</td><td>pointer to the new benchmark</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ae5b5e81cfa4bacb727711dd557da5ddb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int naive_step_interval </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Step the start point of a naive interval to the next benchmark point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine </td></tr>
    <tr><td class="paramname">interval</td><td>pointer to the interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of the last parameter that was incremented or N (the number of parameters) when all paramters overflowed, i.e. the start point could not be stepped and the last naive benchmark has been reached. </dd></dl>

</div>
</div>
<a class="anchor" id="ad78e30d649acfa8e5f348b171365cbd2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structpmm__interval.html">pmm_interval</a>* new_projection_interval </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__paramdef.html">pmm_paramdef</a> *&#160;</td>
          <td class="paramname"><em>pd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new interval that is a projection through a point p, perpendicular to the plane of the d-th element of the point, which is described by the parameter defintion pd</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer to the parameter array describing the point </td></tr>
    <tr><td class="paramname">pd</td><td>pointer to the parameter definition relating to the perpendicular plane </td></tr>
    <tr><td class="paramname">d</td><td>index of the perpendicular plane </td></tr>
    <tr><td class="paramname">n</td><td>number of elements in the point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to a new interval going from p_0,p_1, ... start_d, ... p_n to p_0, p_1, .... end_d, ... p_n </dd></dl>

</div>
</div>
<a class="anchor" id="a1d320975d86d119e6b950c78d4a313d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_interval </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process an interval based on its type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine who's model is being constructed </td></tr>
    <tr><td class="paramname">i</td><td>pointer to the interval to process </td></tr>
    <tr><td class="paramname">b</td><td>pointer to the benchmark that is being inserted to the model </td></tr>
    <tr><td class="paramname">h</td><td>pointer to the load history defining performance fluctuation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if processing is successful, and no further intervals should be processed, 0 if processing is successful but further intervals should be processed, -1 if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="a89d53446deeabfc1cfc6c3380d5e86c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_interval_list </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>process the interval list, with a newly aquired benchmark</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to routine </td></tr>
    <tr><td class="paramname">b</td><td>pointer to benchmark </td></tr>
    <tr><td class="paramname">h</td><td>load history</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on successful processing of interval, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a5a31bb9019f68803df994b90d957ba73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_it_gbbp_bisect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>process a GBBP_BISECT interval</p>
<p>test if the model approximates the new benchmark and in what way,</p>
<p>If the benchmark at the same level as the its left and right neighbours: assume the model is flat in the region of the interaval and finalized this area of the model by removing it.</p>
<p>If the benchmark is at the same level as the left neighbour only, assume that the model is flat to the left of the new benchmark, finalize this area by remoing the interval and replacing it with a new interval representing the area to the right of the benchmark.</p>
<p>In the benchmark is at thte same level as the right neighbour only, preform the same action, but in the inverse, replace the interval with a new interval representing the area to the left of the benchmark</p>
<p>In other cases, look up the current model at the position of the new benchmark.</p>
<p>If the current model accurately represents the new benchmark, replace the construction interval with a new GBBP_INFLECT interval covering the same area.</p>
<p>If the current model does not accurately represent the new benchmark, replace the interval with two new GGBP_BISECT intervals covering the left and right areas between the new benchmark and the previous interval, allowing further refinement of the model</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine </td></tr>
    <tr><td class="paramname">i</td><td>pointer to the interval being processed </td></tr>
    <tr><td class="paramname">b</td><td>pointer to the new benchmark </td></tr>
    <tr><td class="paramname">h</td><td>pointer to the load history</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a60cb009e16d60782c83ab8655545896c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_it_gbbp_climb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a IT_GBBP_CLIMB interval type and associated benchmark. If the new benchmark has a higher speed than the benchmark at the start/left-most point of the interval, then the performance is still climbing. Replace the interval with one that ranges from the new benchmark point to the old old interval end point. The new interval will have the same GBBP_CLIMB type. Otherwise, if the performance is no longer climbing, replace the old interval with a new interval ranging from the new benchmark point to the end of the old interval, but with a GBBP_BISECT type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine that cotains the model </td></tr>
    <tr><td class="paramname">i</td><td>pointer to the interval that the benchmark belongs to </td></tr>
    <tr><td class="paramname">b</td><td>pointer to the benchmark </td></tr>
    <tr><td class="paramname">h</td><td>pointer to the load history (describes performance variance)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>interval i and benchmark b match, m is the correct model, etc.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="adf60cbb408d9407a003eec3a8032a8c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_it_gbbp_empty </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a gbbp_empty type interval. Replace interval with an IT_GBBP_CLIMB interval that starts and ends at the same points as the GBBP_EMPTY interval it replaces.</p>
<p>Note, the new interval must be inserted inplace of the old one, not at the top of the interval list. The start,start,...,start set of parameters match all IT_GBBP_EMPTY intervals for all different boundary planes. We will process all of these intervals, not just the first occurance in the interval list. However, not all of the planes are ready for construction (e.g. their nonzero_end benchmark may not be executed yet). Inserting the next interval (IT_GBBP_CLIMP) inplace of the IT_GBBP_EMPTY interval resolves this issue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the parent routine </td></tr>
    <tr><td class="paramname">i</td><td>pointer to the interval we are processing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>i as the type IT_GBBP_EMPTY</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success </dd></dl>

</div>
</div>
<a class="anchor" id="a1f92d9d73974a4158582f512794c75bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_it_gbbp_inflect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__benchmark.html">pmm_benchmark</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__loadhistory.html">pmm_loadhistory</a> *&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>process a GBBP_INFLECT interval</p>
<p>test if the model approximates the new benchmark and in what way,</p>
<p>Look up the current model at the position of the new benchmark, if the model accurately represents the new benchmark then the model is complete in this area, remove the construction interval.</p>
<p>Otherwise, construction must contine in this area, but:</p>
<p>If the benchmark is at the same level as the left neighbour only, assume that the model is flat to the left of the new benchmark, finalize this area by remoing the interval and replacing it with a new BISECT interval representing the area to the right of the benchmark.</p>
<p>In the benchmark is at thte same level as the right neighbour only, preform the same action, but in the inverse, replace the interval with a new interval representing the area to the left of the benchmark</p>
<p>Otherwise replace the interval with two new GGBP_BISECT intervals covering the left and right areas between the new benchmark and the previous interval, allowing further refinement of the model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine </td></tr>
    <tr><td class="paramname">i</td><td>pointer to the interval being processed </td></tr>
    <tr><td class="paramname">b</td><td>pointer to the new benchmark </td></tr>
    <tr><td class="paramname">h</td><td>pointer to the load history</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a66edda4b90cc972c59e1218936499632"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int process_it_point </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__routine.html">pmm_routine</a> *&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process a point type interval. Remove interval from the interval list and if the list is now empty, add a IT_COMPLETE interval to the list to tag that construction has been completed, also set the complete parameter of the model to 1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>pointer to the routine the benchmark belongs to </td></tr>
    <tr><td class="paramname">i</td><td>pointer to the interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>interval i has a type IT_POINT</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a1982a78477698e3b99563456a3b238f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int project_diagonal_intervals </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__model.html">pmm_model</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assuming all points in the model are along a diagonal constructed by GBBP from start_0, start_1, ..., start_n to end_0, end_1, ..., end_n, project construction intervals through each diagonal point, along mutually perpendicular lines.</p>
<p>Or more formally, given a set n parameter definitions, describing start and end values values: START = start_0, start_1, ..., start_n END = end_0, end_1, ..., end_n</p>
<p>For each point p along a diagonal from a point (start_0,start_1,...,start_n) to (end_0, end_1, ..., end_n) For each element p_i of a point p = (p_0, p_1, ..., p_n) find a point a by replacing p_i in the point p with start_i find a point b by replacing p_i in the point p with end_i create a construction interval between a and b</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>pointer to the model</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a8a969ec8f737d078f23f63752eeec87b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rand_between </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>find a random integer between two values (inclusive)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min</td><td>first integer </td></tr>
    <tr><td class="paramname">max</td><td>second integer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random integer between the two values passed </dd></dl>

</div>
</div>
<a class="anchor" id="a388277f535f308d443164be45ccb5cbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void recurse_mesh </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structpmm__model.html">pmm_model</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>recurse through each plane of a model creating a mesh of benchmark points using the completed parameter boundaries</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>pointer the model </td></tr>
    <tr><td class="paramname">p</td><td>pointer to a parameter array </td></tr>
    <tr><td class="paramname">plane</td><td>current plane </td></tr>
    <tr><td class="paramname">n_p</td><td>number of parameters/planes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0b037601262a05a6d04d07c4f4a1f58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_params_interval_midpoint </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a param array to the midpoint between start and end points of an interval.</p>
<p>Precision is limited to the integer type of the point definition, round up is carried out on the division.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>pointer to the parameter array </td></tr>
    <tr><td class="paramname">i</td><td>pointer to the interval</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>p is allocated and i is an interval of the correct type, with start and end points set (IT_BISECT, IT_INFLECT) </dd></dl>

</div>
</div>
<a class="anchor" id="a67bb6a5e4a0f0a60fa6f72ea571eacc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int set_params_step_along_climb_interval </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__interval.html">pmm_interval</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structpmm__paramdef__set.html">pmm_paramdef_set</a> *&#160;</td>
          <td class="paramname"><em>pd_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Step along the climb interval, from the start point towards the end point, forwards or backwards, a number of times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>pointer to an array to store the parameters at the n-th step along the interval </td></tr>
    <tr><td class="paramname">step</td><td>number of steps to take along the interval (- to step backwards, + to step forwards) </td></tr>
    <tr><td class="paramname">i</td><td>pointer to the interval to step along </td></tr>
    <tr><td class="paramname">pd_set</td><td>pointer to the parameter definition set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>interval should have start and end points set (i.e. be of the type IT_EMTPY, IT_GBBP_CLIMB, IT_GBBP_BISECT, IT_GBBP_INFLECT) though the function is only intended to operate on IT_GBBP_CLIMB interval types</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 if the step will exceed the end-point of the interval or -2 on error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 5 2013 18:17:44 for pmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
